<?xml version="1.0" encoding="utf-8"?>
<!--
   Copyright 2014 Clarius Consulting SA

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <!-- Avoid importing twice by checking for the presence of the VsSDKVersion property -->
    <Import Project="$(VSToolsPath)\VSSDK\Microsoft.VsSDK.targets"
			Condition="'$(VsSDKVersion)' == '' And '$(VSToolsPath)' != ''" />

    <PropertyGroup>
        <!-- This makes it easy to change it to be $(TargetPath) instead -->
        <SmartTemplateIntermediateOutputPath Condition="'$(SmartTemplateIntermediateOutputPath)' == ''">$(IntermediateOutputPath)</SmartTemplateIntermediateOutputPath>
        <SmartTemplateIntermediateOutputFullPath>$([MSBuild]::Escape($([System.IO.Path]::GetFullPath('$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(SmartTemplateIntermediateOutputPath)'))'))))</SmartTemplateIntermediateOutputFullPath>

        <!-- Before compilation is done, we add our content files from smart templates -->
        <PrepareForBuildDependsOn>
            $(PrepareForBuildDependsOn);
            FindSmartTemplateCandidates;
            IncludeSmartTemplateFiles;
            IncludeSmartTemplateIncludes
        </PrepareForBuildDependsOn>
        <!-- Before extension is deployed or VSIX built, we zip templates -->
        <AssignTargetPathsDependsOn>
            CopyOutOfDateSmartTemplateContent;
            ZipSmartTemplateContent;
            AddSmartTemplateZip;
            $(AssignTargetPathsDependsOn)
        </AssignTargetPathsDependsOn>
    </PropertyGroup>


    <!--
    =======================================================================================================
                                    Include all files including the .vstemplate
    =======================================================================================================
	-->
    <Target Name="FindSmartTemplateCandidates">
        <CreateItem Include="@(None)" Condition="'%(None.Extension)' == '.vstemplate'" PreserveExistingMetadata="true">
            <Output TaskParameter="Include" ItemName="SmartVSTemplate" />
        </CreateItem>
    </Target>

    <!--
    =======================================================================================================
                                    Include all files including the .vstemplate
    =======================================================================================================
	-->
    <Target Name="IncludeSmartTemplateFiles" Condition="'@(SmartVSTemplate)' != ''">
        <!-- Causes the wildcards to be resolved to generate one item per file -->
        <CreateItem Include="%(SmartVSTemplate.RelativeDir)**\*.*">
            <Output TaskParameter="Include" ItemName="_SmartTemplateRelativeFile" />
        </CreateItem>

        <!-- Leverage built-in task to assign TargetPath metadata -->
        <AssignTargetPath Files="@(_SmartTemplateRelativeFile)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="SmartTemplateContentWithTargetPath" />
        </AssignTargetPath>
    </Target>

    <!--
    =======================================================================================================
							Include files added via semicolon-delimited <Include> metadata
    =======================================================================================================
	-->
    <Target Name="IncludeSmartTemplateIncludes"
			Inputs="@(SmartVSTemplate)"
			Outputs="@(SmartVSTemplate -> %(Identity)-BATCH)"
			Condition="'@(SmartVSTemplate)' != ''">
        <!-- Splits by semicolon the Includes metadata of the template and generates one item for each
		     note that we're already batching the entire targets so that the SplitTemplateIncludes always 
		     receives a single template file to perform the split on -->
        <SplitTemplateIncludes Template="@(SmartVSTemplate)" Condition="'%(SmartVSTemplate.Include)' != ''">
            <Output ItemName="_SmartTemplateInclude" TaskParameter="Includes" />
        </SplitTemplateIncludes>

        <!-- Causes the wildcards to be resolved to generate one item per file -->
        <CreateItem Include="@(_SmartTemplateInclude)" PreserveExistingMetadata="true">
            <Output TaskParameter="Include" ItemName="_SmartIncludedFileSource" />
        </CreateItem>

        <!-- Calculates the relative target path for each item under the target template directory -->
        <AssignIncludeTargetPaths Files="@(_SmartIncludedFileSource)">
            <Output TaskParameter="AssignedFiles" ItemName="SmartTemplateContentWithTargetPath" />
        </AssignIncludeTargetPaths>
    </Target>

    <!--
    =======================================================================================================
							Copies out of date template content (included or direct)
                            to the $(SmartTemplateIntermediateOutputPath) prior to zipping
    =======================================================================================================
	-->
    <Target
        Name="CopyOutOfDateSmartTemplateContent"
        Condition="'@(SmartTemplateContentWithTargetPath)' != ''"
        Inputs="@(SmartTemplateContentWithTargetPath)"
        Outputs="@(SmartTemplateContentWithTargetPath->'$(SmartTemplateIntermediateOutputPath)%(TargetPath)')">

        <Copy
            SourceFiles="@(SmartTemplateContentWithTargetPath)"
            DestinationFiles="@(SmartTemplateContentWithTargetPath->'$(SmartTemplateIntermediateOutputPath)%(TargetPath)')"
            OverwriteReadOnlyFiles="true"
            Retries="$(CopyRetryCount)"
            RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
            SkipUnchangedFiles="true">
            <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
        </Copy>

    </Target>


    <!--
    =======================================================================================================
                                       Zip the intermediate content, if changed
    =======================================================================================================
    -->
    <Target Name="ZipSmartTemplateContent" Condition="'@(SmartVSTemplate)' != ''">

        <ItemGroup>
            <_SmartTemplateContent Include="$(SmartTemplateIntermediateOutputFullPath)%(SmartVSTemplate.RelativeDir)**\*.*">
                <ZipRootDir>$([System.IO.Directory]::GetParent($(SmartTemplateIntermediateOutputFullPath)%(SmartVSTemplate.RelativeDir)).FullName)\</ZipRootDir>
                <ZipFile>$([System.IO.Directory]::GetParent($(SmartTemplateIntermediateOutputFullPath)%(SmartVSTemplate.RelativeDir)).Parent.FullName)\%(SmartVSTemplate.Filename).zip</ZipFile>
            </_SmartTemplateContent>
        </ItemGroup>

        <!--
			The following VSSDK built-in task takes care of zipping a template. It doesn't do any pre or post-processing 
			of the .vstemplate, which is exactly what we want as we may have links, etc. This is the opposite of what 
			the built-in VSTemplate build action does, which mangles everything and breaks badly with linked files, 
			multi-project templates, etc.
			
			It doesn't re-zip if files haven't changed also.
		-->
        <ZipItems Files="@(_SmartTemplateContent)"
                  Action="New"
                  ProjectPath="$(SmartTemplateIntermediateOutputFullPath)"
                  RootPath="%(_SmartTemplateContent.ZipRootDir)"
                  ZipFile="%(_SmartTemplateContent.ZipFile)">
            <Output TaskParameter="ZipFile" ItemName="_SmartTemplateZip" />
        </ZipItems>
    </Target>

    <!--
    =======================================================================================================
                                       Add as content to be included in the VSIX
    =======================================================================================================
    -->
    <Target Name="AddSmartTemplateZip" Condition="'@(SmartVSTemplate)' != ''">
        <ItemGroup>
            <FileWrites Include="@(_SmartTemplateZip)" />
            <Content Include="@(_SmartTemplateZip)">
                <!-- This Link is used by the VSSDK target to set the VSIXSubPath directory where the item will be deployed/added to the vsix -->
                <Link>$([System.IO.Directory]::GetParent(%(_SmartTemplateZip.FullPath)).FullName.Replace($(SmartTemplateIntermediateOutputFullPath), ''))\%(_SmartTemplateZip.Filename)%(_SmartTemplateZip.Extension)</Link>
                <IncludeInVSIX>true</IncludeInVSIX>
                <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
            </Content>
        </ItemGroup>
    </Target>

    <PropertyGroup>
        <CodeTaskAssembly>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll</CodeTaskAssembly>
		<!-- In VS2013, the assembly contains the VS version. -->
		<CodeTaskAssembly Condition="!Exists('$(CodeTaskAssembly)')">$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(VisualStudioVersion).dll</CodeTaskAssembly>
        <!-- In VS2014+, the assembly was renamed. -->
        <CodeTaskAssembly Condition="!Exists('$(CodeTaskAssembly)')">$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll</CodeTaskAssembly>
    </PropertyGroup>


    <!--
    =======================================================================================================
                                       Task that splits the <Include> metadata

    If a template contains the following metadata:
    
        <SmartVSTemplate Include="\T\PT\MyApp\MyApp.vstemplate">
            <Include>..\..\Shared\Common\**\*.*;..\..\Shared\CSharp\**\*.*</Include>
        </SmartVSTemplate>
    
    This task will generate as output the following two items>

      <Item Include="..\..\Shared\Common\**\*.*">
        <TemplateDir>\T\PT\MyApp\</TemplateDir>
        <TemplateParentDir>\T\PT\</TemplateParentDir>
        <TemplateZip>MyApp.zip</TemplateZip>
        <IncludedDir>..\..\Shared\Common\</IncludedDir>
      </Item>
      <Item Include="..\..\Shared\CSharp\**\*.*"
        <TemplateDir>\T\PT\MyApp\</TemplateDir>
        <TemplateZip>MyApp.zip</TemplateZip>
        <IncludedDir>..\..\Shared\CSharp\</IncludedDir>
      </Item>
    
    This allows the consuming target to force the wildcards to be resolved and obtain 
    a final list of items to include, as well as preserve the originating template 
    directory and ultimate target zip file that will contain the items.

    =======================================================================================================
    -->
    <UsingTask TaskName="SplitTemplateIncludes" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskAssembly)">
        <ParameterGroup>
            <Template ParameterType="Microsoft.Build.Framework.ITaskItem" Required="true" />
            <Includes ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
        </ParameterGroup>
        <Task>
            <Using Namespace="System.IO" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
var templateFullDir = this.Template.GetMetadata("RootDir") + this.Template.GetMetadata("Directory");
var templateRelativeDir = this.Template.GetMetadata("RelativeDir");
var templateInclude = this.Template.GetMetadata("Include") ?? "";
this.Includes = templateInclude
					.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries)
					.Select(include => new TaskItem(Path.Combine(templateFullDir, include), new Dictionary<string, string>
					{
						{ "TemplateDir", templateRelativeDir },
						{ "IncludedDir", include.IndexOf("**") != -1 ?
								// We have a relative dir in the path.
								new DirectoryInfo(Path.Combine(templateFullDir, include.Substring(0, include.IndexOf("**")))).FullName :
								// We don't have relative dirs, so just pick the path.
								new DirectoryInfo(Path.Combine(templateFullDir, include.Substring(0, include.LastIndexOf(@"\") + 1))).FullName
						}
					}))
					.ToArray();
]]>
            </Code>
        </Task>
    </UsingTask>

    <!--
    =======================================================================================================
                                     Task that calculates the target relative paths

    For a template under \T\PT\MyApp\MyApp.vstemplate that includes ..\..\Shared\**\*.*, we would have 
    a new item like
    
        <Item Include="..\..\Shared\Docs\Readme.txt">
            <Link>T\PT\MyApp\Docs\Readme.txt</Link>
        </Item>
    
    Notice how the included item points to each of the items found based on the include with wildcards
    (if any) and how the resulting Link is properly relative as found under Shared, with the recursive 
    dir (Docs\ in this case) added to the relative location destination. This means that the structure 
    of wildcard-included folders is mirrored under the smart template directory.
    =======================================================================================================
    -->
    <UsingTask TaskName="AssignIncludeTargetPaths" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskAssembly)">
        <ParameterGroup>
            <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
            <AssignedFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
        </ParameterGroup>
        <Task>
            <Using Namespace="System.IO" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
this.AssignedFiles = this.Files.Select(i => new TaskItem(i)).ToArray();                
foreach(var item in this.AssignedFiles)
{
	item.SetMetadata("Link", 
		Path.Combine(item.GetMetadata("TemplateDir"), 
			new FileInfo(item.GetMetadata("FullPath"))
				.FullName.Replace(item.GetMetadata("IncludedDir"), "")
		));
    
    // For compatibility with the built-in AssignTargetPath task that runs for content files.
	item.SetMetadata("TargetPath", item.GetMetadata("Link"));
}
]]>
            </Code>
        </Task>
    </UsingTask>

</Project>
